Video 1 and 2 Are basically INTROS

Video 3- How Does Angular Interact with Backends?
 We dont access databases directly with Angualr because that would be very insecure allowing others to see our info. Instead we go to a server first and through the use of an API we make those
requests, fetch and save data, run anayltics and more 

Video 4- Anatomy of an HTTP Request
Based on his videos :
 We need th URL otherwise called an API endpoint. Where are we going? <<<URL DEFINITION: A URL (Uniform Resource Locator) is a unique identifier that helps a computer find a resource on a network.>> where we will usually have a domain and a path

THen we will have some kind of HTTP VERB USUALLY : GET, POST, PUT, PATCH and there are a few more. My understanding is that GET is to fetch data, POST is to create or add datam, PUT is simiilar to POST BUT to create or OVERWRITE data aka a new updated list, and PATCH is partial modifications to a resourse. 

THen ther are HEADERS for metadata but this is typically done automaticaly and built in although we can alter it. 

then the BODY of the message which is the data itself and includes the POST,PUT, ETC> VERBS 

Video 5- Backend Firebase Setup
HEre we basically use our google account to go to Console on the Firebase website adn create and name a new project. WE use REaltime Database option, create Database, then use the URL that is generated in our ANGULAR project. 


Video 6- SEnding a POST request 

In this lecture we saw that when we submit a form, with the method OnCreatePost, we pass arguments for postData being a title and content to conincide with the form data.  We are also injecting the value we named http: type HttpClient in this compoenent so we can use the tools it brings into our onCreatePost method. 

So  the body of our method we are aying this.http.post     then passing as arguments in there first the URL or API endpoint of our new firebase database we made for this. WE are also adding a a folder onto it with "/posts", next we are passing the body of content we want to post and we do that with "postData") but  BUTTTTTTTTTTT it will only send this request to post if we subscribe to it otherwise it will not because no one is interested in it.  so we add .subsrcibe and add responseData with a callback function and console log that response data. 

Here is the code as part of the TS file for this example: 

constructor(private http: HttpClient) {}

  ngOnInit() {}

  onCreatePost(postData: { title: string; content: string }) {
    // Send Http request
    this.http.post('https://first-test-project-a4b02-default-rtdb.firebaseio.com/posts.json', postData)
    .subscribe(responseData => {
      console.log(responseData);
    });
  }


Video 7 -GETting Data

Questions: Why do we need to crate a private fetchPosts() method? Why not just the regular one? 

?
In this lecture we created a private fetchPosts method where we use this.http.get and then JUST THE URL as the only argument because GET requests only need one ARGUMENT and not a second argument which is reservered for a message body because a GET request has no message as it is asking for info not delivering it. 
So that looks like this: 
 private fetchPosts() {
    this.http
      .get(
        "https://first-test-project-a4b02-default-rtdb.firebaseio.com/posts.json"
      )
      .subscribe((posts) => {
        console.log(posts);
      });

------we then add that fetchPost method to the regular fetchPost method like this, and this might be so that whoever has access to the button doesn't have access to the actual code but then why not for the post method?
Where this fetchPost() is tied to the event click listener in the html on the fetch button. 

onFetchPosts() {
this.fetchPosts();
  };

----_THEN we add that same method to the ngOnInit method so that anytime this page loads it actually will fetch our data. So then why have a button at all? 
Looks like this--

ngOnInit() {
    this.onFetchPosts();
  }

When we do this it returns in the console log because of how our methods are set up a javascript object where the key:value pair is a cryptic key and the value is a nested object which ncludes the data we entered for our post.    NOW if we want to save the posts to a variable array, we need to be able to transform the data and we do that in the next lecture with OBSERVABLE OPERATORS.

VIDEO 8- Using RxJS Operators to Transform Response Data 

In this lecture we are inporting the map operator. after the get method we are using a pipe to transform the data and
we do that by mapping the resonseData and callback method to assign a new array called postsArray and a for loop? to assign a new "key" variable value of every responseData if the responseData has a unique key, then it will push that data onto the new postsArray and we return the new postsArray. 
============
.get(
        "https://first-test-project-a4b02-default-rtdb.firebaseio.com/posts.json"
      )
      .pipe(
        map(responseData => {
          const postsArray= [];
          for (const key in responseData) {
            if (responseData.hasOwnProperty(key)) {
              postsArray.push({...responseData[key], id:key});
            }
          }
          return postsArray;
        })

My questions on this are just i need a walk through of this and how it works exactly.



























































































